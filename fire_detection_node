import rclpy
from rclpy.node import Node
import sys
sys.path.insert(0, '/home/jh/myenv/lib/python3.12/site-packages')

import onnxruntime as ort
import numpy as np
import cv2
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge
from geometry_msgs.msg import Point

class FireDetectionNode(Node):
    def __init__(self):
        super().__init__('fire_detection_node')

        # Declare parameters
        self.declare_parameter('confidence_threshold', 0.4)
        self.declare_parameter('class_id', 1)  # Fire's class id is 1.
        
        self.confidence_threshold = self.get_parameter('confidence_threshold').get_parameter_value().double_value
        self.fire_class_id = self.get_parameter('class_id').get_parameter_value().integer_value
        
        # model load
        self.session = ort.InferenceSession('/home/jh/yolov5/best.onnx')

        # Camera initializing
        self.bridge = CvBridge()
        self.image_sub = self.create_subscription(Image, '/image_raw', self.image_callback, 10)
        self.info_sub = self.create_subscription(CameraInfo, '/camera_info', self.info_callback, 10)

        self.last_image = None
        self.camera_info = None

        # Topic publish
        self.fire_location_publisher = self.create_publisher(Point, 'fire_location', 10)

    def info_callback(self, msg):
        self.camera_info = msg

    def image_callback(self, msg):
        if self.camera_info is None:
            return
        
        # conversion ros-cv
        cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
        height, width, _ = cv_image.shape

        # Preprocess image
        resized_image = cv2.resize(cv_image, (640, 640))
        input_image = resized_image.transpose((2, 0, 1)) 
        input_image = np.expand_dims(input_image, axis=0).astype(np.float32) / 255.0
        
        inputs = {self.session.get_inputs()[0].name: input_image}
        outputs = self.session.run(None, inputs)
        
        # detection
        boxes = self.process_detections(outputs[0], (height, width))
        if boxes:
            for box in boxes:
                x_min, y_min, x_max, y_max = box
                x_center = (x_min + x_max) / 2
                y_center = (y_min + y_max) / 2
                
                fire_point = Point()
                fire_point.x = float(x_center)
                fire_point.y = float(y_center)
                fire_point.z = 0.0 
                
                self.fire_location_publisher.publish(fire_point)
                self.get_logger().info(f'Fire detected at center: ({x_center}, {y_center})')
        else:
            self.get_logger().info('No fire detected')

    def process_detections(self, detections, frame_shape):
        detections = detections[0]
        boxes = []
        height, width = frame_shape[:2]

        for detection in detections:
            if len(detection) == 6: 
                x_center, y_center, w, h, conf, class_id = detection
                class_id = int(round(class_id))

                if conf > self.confidence_threshold and class_id == self.fire_class_id:
                    x_center, y_center, w, h = float(x_center), float(y_center), float(w), float(h)
                    x_min = int(x_center - (w / 2))
                    y_min = int(y_center - (h / 2))
                    x_max = int(x_center + (w / 2))
                    y_max = int(y_center + (h / 2))
                    x_min = max(0, x_min)
                    y_min = max(0, y_min)
                    x_max = min(width, x_max)
                    y_max = min(height, y_max)
                    boxes.append((x_min, y_min, x_max, y_max))

        return boxes

def main(args=None):
    rclpy.init(args=args)
    node = FireDetectionNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
